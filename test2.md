---
создал заметку: "2025-11-27"
---
## Наследование 

### Агрегирование  
При таком подходе старый класс является частью нового класса в виде одного из полей. 

Класс А - старый класс
Класс В - новый класс 
Конструируем В опираясь на А 
m - метод класса А 
В классе В поля типа А
**b.a1.m()** - вызов метода m() класса а через класс b
### Наследование 
Один класс может использоваться  наследовании **ТОЛЬКО** один раз

**b.m()** - вызов метода из класса а напрямую через класс b, благодаря наследованию 

**Агрегирование** применяется когда старый класс А - инструмент для работы нового класса B

**Наследование** применяется когда новый класс B дополняет, улучшает, развивает, упрощает или модифицирует поведение родительского (старого) класса A


```Cpp 
// НАСЛЕДОВАНИЕ

class Point3D 
{
	.....
	void setZ(...)
	.....
};

class Point2D : public Point3D // public здесь - тип наследованиея 
{
	.....
private:
	void setZ(....) {}
};
```
Лишнюю логику можно прятать

-> наследование
A->B
A->C
В->D
C->D
как вызвать метод m() из А через D? 
вот так:
``d.B::m();``
**ромбовидное наследование** - проблема
нельзя обратиться не к своему непосредственному родителю, только на поколение назад, не через одно и больше!

**protected** - это раздел класса, элементы которого доступны только из класса или его наследников, снаружи они не видны (так же, как и private и public)

типы наследования:
1. **public** - разделы остаются public
2. **private** - все разделы становятся private
3. **protected** - public становится protected

**Дружественный метод** имеет доступ к разделу private вашему класса
если класс дружественный, то из любого места класса А будет доступ к private классу B

Дружественность не наследуется, если класс А дружит с классом В, то класс Д при наследовании из класса В не будет наследовать возможность обращаться к приватным полям класса А (дружественность не будет передана через наследование)

**Базовый класс** - класс, в котором прописаны методы  

```Cpp
Class A
{
	....
public:
	A(int a, float b)
};

Class B
{
	....
	friend class A; // класс А может обращатсья к приватным полям класса B
};
```

```Cpp
Class A
{
	....
public:
	A(int a, float b) : a(a), b(b), c(0) {} // инициализация константной переменной таким образом возможно в конструкторе
private:
	....
	const c;
};

Class B : public A
{
public: 
	B() : A(0, 0) {....} // Обращение к конструкторам родительских классов и конструкторам полей 
};

B b; // создаем объект класса В 
```
