---
создал заметку: "2025-11-27"
---
## Наследование 

### Агрегирование  
При таком подходе старый класс является частью нового класса в виде одного из полей. 

Класс А - старый класс
Класс В - новый класс 
Конструируем В опираясь на А 
m - метод класса А 
В классе В поля типа А
**b.a1.m()** - вызов метода m() класса а через класс b
### Наследование 
Один класс может использоваться  наследовании **ТОЛЬКО** один раз

**b.m()** - вызов метода из класса а напрямую через класс b, благодаря наследованию 

**Агрегирование** применяется когда старый класс А - инструмент для работы нового класса B

**Наследование** применяется когда новый класс B дополняет, улучшает, развивает, упрощает или модифицирует поведение родительского (старого) класса A


```Cpp 
// НАСЛЕДОВАНИЕ

class Point3D 
{
	.....
	void setZ(...)
	.....
};

class Point2D : public Point3D // public здесь - тип наследованиея 
{
	.....
private:
	void setZ(....) {}
};
```
Лишнюю логику можно прятать

-> наследование
A->B
A->C
В->D
C->D
как вызвать метод m() из А через D? 
вот так:
``d.B::m();``
**ромбовидное наследование** - проблема
нельзя обратиться не к своему непосредственному родителю, только на поколение назад, не через одно и больше!

**protected** - это раздел класса, элементы которого доступны только из класса или его наследников, снаружи они не видны (так же, как и private и public)

типы наследования:
1. **public** - разделы остаются public
2. **private** - все разделы становятся private
3. **protected** - public становится protected

**Дружественный метод** имеет доступ к разделу private вашему класса
если класс дружественный, то из любого места класса А будет доступ к private классу B

Дружественность не наследуется, если класс А дружит с классом В, то класс Д при наследовании из класса В не будет наследовать возможность обращаться к приватным полям класса А (дружественность не будет передана через наследование)

**Базовый класс** - класс, в котором прописаны методы  

```Cpp
Class A
{
	....
public:
	A(int a, float b)
};

Class B
{
	....
	friend class A; // класс А может обращатсья к приватным полям класса B
};
```

```Cpp
Class A
{
	....
public:
	A(int a, float b) : a(a), b(b), c(0) {} // инициализация константной переменной таким образом возможно в конструкторе
private:
	....
	const c;
};

Class B : public A
{
public: 
	B() : A(0, 0) {....} // Обращение к конструкторам родительских классов и конструкторам полей 
};

B b; // создаем объект класса В 
```
Конструкторы являются индивидуальной чертой каждого класса и они не наследуются, конструктор нельзя вызвать, к нему можно только обратиться 

## Полиморфизм 
**Полиморфизм** - это свод неких правил того, как взаимодействуют классы, имеющие общих родителей

А -> B
A -> C
Как работать с общей логикой из класса А в классах B и C?

**Пример:**
Необходимо разработать 3 класса:
- **Shape** (форма)
x, y - центр
name - имя
от shape наследуются 2 фигуры:
- **rectangle** 
стороны a, b
- **circle**
r - радиус

**Задача:**
Создать массив, в котором хранились бы одновременно прямоугольники и окружности (не имеет решения, но мы потом решим)

Создавать объекты типа shape **нельзя** 

```Cpp
class Shape 
{
public:
	Shape(int x, int y, std::string name) : x(x), y(y), name(name) {}
private:
	.... // объявление полей
	
	
};

class Rectangle : public Shape
{
public: 
	Rectangle(int a, int b, in x, int y, std::string name) : Shape(x,y,name), a(a), b(b) // обращаемся к конструкторам родительского класса чтобы задать параметры x y name
	double area() {.....}
	virtual doube area() = 0; // чистый спецификатор, вся строка называется чистой виртуальной функцией, и это и есть указатель на функцию, логики у нее нет. создавать объекты класса, содержащего чистые виртуальные функции нельзя синтаксически. если в классе содержатся только чистые виртуальные методы, то класс называется интерфейсом (виртуальным абстрактным классом). Это нужно для того, чтобы работала строка 39-40
private:
	
};

class Circle : public Shape 
{
	.... // по аналогии с rectangle 
	double area() {....}
};

main.cpp

int main() {
	Rectangle r1(....);
	Circle c1(....);
	
	Shape *s1 = new Circle(....);
	
	// массив указателей на shape, но на самом деле на rectangle и circle 
	Shape *shapes[] = {&r1, &c1, s1, new Rectangle(...)};
	
	for (auto shape : shapes) {
		std::cout << shape->area() << std::endl; // 
	} ошибка, так как пока нету area() в классе shape 
	delete []shapes;
	delete s1;
	return 0;
};


```
**Виртуальный метод** - то же самое, что и **указатель на функцию**

---
## ДЗ
1. Изменить пример про точку 2д, добавить точку 3д используя наследования и тд, точка 2д наследуется от точки 3д 
2. про вектора: необходимо создать класс, который агрегировал бы массив векторов, реализующий векторной множество
3. написание класса матрица 