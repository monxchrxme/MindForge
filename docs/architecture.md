# Architecture.md - Архитектура проекта MindForge Quiz Plugin.

## 1. Общий обзор системы

### Цель проекта
MindForge Quiz Plugin — это интеллектуальный плагин для Obsidian, предназначенный для студентов и людей, которые активно учатся. Система автоматически анализирует заметки пользователя и генерирует персонализированные квизы для закрепления материала, помогая перенести информацию из краткосрочной памяти в долгосрочную.

### Ключевые возможности (версия для предзащиты)
- **Parser Agent с RAG**: Анализ заметок и извлечение ключевых концепций с использованием Retrieval Augmented Generation
- **Quiz Agent**: Генерация разнообразных вопросов на основе извлеченных концепций
- **Кэширование**: Интеллектуальное кэширование результатов парсинга для оптимизации работы
- **Поддержка длинных заметок**: RAG система позволяет эффективно работать с объемными лекциями

### Целевые пользователи
- Студенты университетов и колледжей
- Школьники старших классов
- Специалисты, проходящие самообучение
- Пользователи Obsidian, ведущие конспекты лекций

### Сценарии использования
1. **Подготовка к экзаменам**: Студент делает конспект лекции в Obsidian → система генерирует квиз → студент проходит тест для закрепления материала
2. **Самопроверка**: После изучения нового материала пользователь проверяет свое понимание темы
3. **Повторение**: Периодическое прохождение квизов по старым заметкам для долгосрочного запоминания

***

## 2. Высокоуровневая архитектура системы

### Архитектурная диаграмма

```
┌─────────────────────────────────────────────────────────────┐
│                     USER INPUT                              │
│                 (Markdown заметка)                          │
└───────────────────────────┬─────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│                    QUIZ PIPELINE                            │
│                   (main.py)                                 │
│  • Загрузка заметки                                         │
│  • Кэширование (hash-based)                                 │
│  • Координация агентов                                      │
└───────────┬─────────────────────────────┬───────────────────┘
            │                             │
            ▼                             ▼
┌─────────────────────────┐   ┌──────────────────────────────┐
│    PARSER AGENT         │   │      QUIZ AGENT              │
│  (parser_agent.py)      │   │   (quiz_agent.py)            │
│                         │   │                              │
│  • Извлечение тем       │   │  • Генерация вопросов        │
│  • Анализ концепций     │───┤  • Форматирование квиза      │
│  • Генерация резюме     │   │  • Валидация вопросов        │
└───────────┬─────────────┘   └──────────────────────────────┘
            │                            
            ▼                            
┌─────────────────────────────────────────────────────────────┐
│                    RAG SYSTEM                               │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐       │
│  │  Embeddings  │  │ Vector Store │  │  Retriever   │       │
│  │  Generator   │──│  (ChromaDB)  │──│              │       │
│  └──────────────┘  └──────────────┘  └──────────────┘       │
│  • Разбиение на чанки (500 токенов + 100 overlap)           │
│  • Векторизация через GigaChat Embeddings                   │
│  • Семантический поиск (top_k=3)                            │
└───────────────────────────┬─────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│              GIGACHAT API (External Service)                │
│  • Языковая модель GigaChat                                 │
│  • Embeddings API                                           │
│  • Structured Output (Pydantic)                             │
└─────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│                    OUTPUT (JSON)                            │
│  • Parsed Concepts                                          │
│  • Generated Quiz                                           │
│  • Metadata                                                 │
└─────────────────────────────────────────────────────────────┘
```

### Поток данных

```
Markdown Note → QuizPipeline → Parser Agent → RAG System → Concepts
                                                             ↓
                                              Quiz Agent ← Concepts
                                                             ↓
                                                        JSON Quiz
```

***

## 3. Описание архитектурных компонентов

### 3.1 QuizPipeline (main.py)

**Назначение**: Главный оркестратор системы, координирующий работу всех компонентов.

**Ключевые функции**:
- Загрузка и валидация заметок
- Управление кэшем (hash-based caching)
- Последовательный вызов Parser Agent → Quiz Agent
- Форматирование финального вывода

**Входные данные**: Путь к файлу заметки (Markdown)

**Выходные данные**: JSON объект с концепциями и квизом

**Технологии**: Python 3.10+, pathlib, logging

**Особенности реализации**:
- Кэширование основано на MD5 хеше содержимого заметки
- Если заметка не изменилась — парсинг не повторяется
- CLI интерфейс для демонстрации на предзащите

***

### 3.2 Parser Agent (parser_agent.py)

**Назначение**: Интеллектуальный анализ заметки с извлечением ключевых концепций, использует RAG для работы с длинными текстами.

**Входные данные**: Текст заметки (str)

**Выходные данные**: `ParsedNote` объект (Pydantic model):
```python
{
  "concepts": [
    {
      "title": "Квантовая механика",
      "description": "Раздел физики...",
      "importance": "high",
      "context": "релевантная цитата"
    }
  ],
  "summary": "Краткое резюме заметки"
}
```

**Технологии**: GigaChat API, GigaChain, Pydantic

**Алгоритм работы**:
1. **Chunking**: Разбиение заметки на чанки (500 символов + 100 overlap)
2. **Indexing**: Индексация чанков в векторную БД через RAG систему
3. **Topic Extraction**: Извлечение 5-7 основных тем через LLM
4. **RAG Retrieval**: Для каждой темы поиск релевантных чанков
5. **Detailed Analysis**: Детальный анализ каждой темы с контекстом
6. **Summary Generation**: Создание общего резюме заметки

**Промпт-стратегия**:
- Extraction prompt для извлечения тем
- Analysis prompt с контекстом из RAG для детального анализа
- Structured output через Pydantic для надежного формата

**Особенности реализации**:
- Наследуется от `BaseAgent`
- Использует dependency injection для RAG компонентов
- Логирование всех этапов обработки

***

### 3.3 Quiz Agent (quiz_agent.py)

**Назначение**: Генерация образовательных вопросов на основе концепций из Parser Agent.

**Входные данные**: `ParsedNote` объект

**Выходные данные**: `Quiz` объект (Pydantic model):
```python
{
  "questions": [
    {
      "question_text": "Что изучает квантовая механика?",
      "question_type": "multiple_choice",
      "options": ["A", "B", "C", "D"],
      "correct_answer": "B",
      "explanation": "Краткое объяснение",
      "difficulty": "medium"
    }
  ],
  "total_questions": 7
}
```

**Технологии**: GigaChat API, Pydantic

**Типы генерируемых вопросов**:
1. **Multiple Choice**: 4 варианта ответа
2. **True/False**: Утверждение с проверкой истинности
3. **Short Answer**: Краткий текстовый ответ

**Алгоритм работы**:
1. Распределение вопросов по концепциям (равномерно)
2. Для каждой концепции: генерация N вопросов через LLM
3. Валидация структуры вопросов (Pydantic)
4. Формирование финального квиза

**Промпт-стратегия**:
- **Few-shot learning**: Промпт включает 2-3 примера качественных вопросов
- **Structured output**: Требование JSON формата с Pydantic schema
- **Diversity instruction**: Инструкция генерировать разнообразные типы вопросов

**Параметры генерации**:
- `num_questions`: 7 (по умолчанию, настраивается в config.yaml)
- `temperature`: 0.7 (баланс между креативностью и надежностью)
- `top_k concepts`: Приоритет высокоимпортантным концепциям

***

### 3.4 RAG System (rag/)

#### 3.4.1 EmbeddingGenerator (embeddings.py)

**Назначение**: Генерация векторных представлений текста через GigaChat Embeddings API.

**Технологии**: GigaChat Embeddings API, NumPy

**Методы**:
- `generate_embedding(text)`: Одиночный эмбеддинг
- `generate_embeddings_batch(texts)`: Батч обработка для оптимизации

**Размерность векторов**: Зависит от модели GigaChat (обычно 768 или 1024)

**Особенности**:
- Кэширование на уровне векторной БД
- Обработка ошибок API
- Batch processing для минимизации вызовов API

#### 3.4.2 VectorStore (vector_store.py)

**Назначение**: Хранение и поиск векторных представлений чанков.

**Технологии**: ChromaDB (основной выбор) или FAISS (альтернатива)

**Выбор ChromaDB обоснован**:
- ✅ Легкая настройка (embedded database)
- ✅ Персистентность данных
- ✅ Встроенная поддержка метаданных
- ✅ Хорошая производительность для небольших объемов

**Методы**:
- `add_documents(chunks)`: Индексация чанков
- `search(query, top_k)`: Семантический поиск
- `clear()`: Очистка БД

**Структура хранения**:
```python
{
  "id": "chunk_0",
  "embedding": [0.123, 0.456, ...],  # 768-dim vector
  "document": "Текст чанка",
  "metadata": {}
}
```

**Параметры индексации**:
- Chunk size: 500 символов
- Overlap: 100 символов
- Distance metric: Cosine similarity (по умолчанию в ChromaDB)

#### 3.4.3 Retriever (retriever.py)

**Назначение**: Высокоуровневая логика поиска релевантной информации.

**Методы**:
- `retrieve(query, top_k)`: Основной поиск
- `retrieve_with_scores()`: Поиск с оценками релевантности (для будущих версий)

**Параметры**:
- `top_k`: 3 (оптимальный баланс между контекстом и точностью)

**Алгоритм**:
1. Получить query от Parser Agent
2. Векторизовать query через EmbeddingGenerator
3. Поиск в VectorStore по косинусному сходству
4. Возврат top_k наиболее релевантных чанков

***

### 3.5 Utilities (utils/)

#### GigaChatClient (gigachat_client.py)

**Назначение**: Единая обертка для работы с GigaChat API.

**Методы**:
- `generate(prompt)`: Генерация текста
- `generate_structured(prompt, response_model)`: Structured output с Pydantic

**Особенности**:
- Обработка ошибок API
- Извлечение JSON из текста ответа
- Retry логика (для будущих версий)
- Логирование всех запросов

**Конфигурация**:
```python
{
  "api_key": "...",
  "model": "GigaChat",
  "temperature": 0.7,
  "max_tokens": 2000
}
```

#### Helpers (helpers.py)

**Функции**:
- `chunk_text()`: Разбиение текста с overlap
- `calculate_hash()`: MD5 хеш для кэширования
- `load_note()`: Загрузка Markdown файла
- `format_quiz_output()`: JSON форматирование
- `load_config()`: Загрузка YAML конфигурации

***

### 3.6 BaseAgent (base_agent.py)

**Назначение**: Абстрактный базовый класс для всех агентов.

**Интерфейс**:
```python
class BaseAgent(ABC):
    @abstractmethod
    def process(self, input_data) -> Any:
        """Основная логика агента"""
        pass
```

**Общая функциональность**:
- Инициализация с конфигурацией
- Логирование (agent-specific logger)
- Методы `log_input()` и `log_output()`

**Преимущества**:
- Единообразный интерфейс для всех агентов
- Упрощает добавление новых агентов (Explain, Orchestrator)
- Централизованное логирование

***

## 4. Потоки данных и сценарии использования

### 4.1 Основной сценарий: Генерация квиза

**Шаг 1: Инициализация**
```
User → CLI command: python -m src.main lecture_notes.md
     ↓
QuizPipeline.__init__()
     ↓
Load config.yaml
     ↓
Initialize: Parser Agent, Quiz Agent
```

**Шаг 2: Обработка заметки**
```
QuizPipeline.process_note(path)
     ↓
Load note content (UTF-8)
     ↓
Calculate MD5 hash
     ↓
Check cache: hash in self.cache?
     ├─ YES → Use cached ParsedNote
     └─ NO  → Continue to Step 3
```

**Шаг 3: Парсинг с RAG**
```
ParserAgent.parse(note_content)
     ↓
chunk_text(content, size=500, overlap=100)
     ↓
VectorStore.add_documents(chunks)
     ├─ EmbeddingGenerator.generate_embeddings_batch()
     └─ ChromaDB.add(embeddings, documents, ids)
     ↓
Extract main topics via GigaChat (5-7 topics)
     ↓
For each topic:
     ├─ Retriever.retrieve(topic, top_k=3)
     ├─ VectorStore.search() → relevant chunks
     └─ Analyze topic with context via GigaChat
     ↓
Generate summary via GigaChat
     ↓
Return ParsedNote(concepts, summary)
     ↓
Cache result: self.cache[hash] = ParsedNote
```

**Шаг 4: Генерация квиза**
```
QuizAgent.generate_quiz(ParsedNote)
     ↓
Calculate questions per concept
     ↓
For each concept:
     ├─ Build prompt (with few-shot examples)
     ├─ GigaChatClient.generate_structured(prompt, Question)
     └─ Validate with Pydantic
     ↓
Collect all questions (limit to num_questions)
     ↓
Return Quiz(questions, total_questions)
```

**Шаг 5: Вывод результата**
```
format_quiz_output(Quiz)
     ↓
JSON.dumps(indent=2, ensure_ascii=False)
     ↓
Print to console
```

### 4.2 Временные характеристики

**Для заметки ~2000 слов**:
- Chunking: ~0.1 сек
- Индексация в ChromaDB: ~1-2 сек
- Извлечение тем (1 API call): ~3-5 сек
- Анализ концепций (5-7 API calls): ~15-25 сек
- Генерация квиза (7 API calls): ~20-30 сек
- **Общее время**: ~40-60 сек (первый запуск)
- **Повторный запуск** (с кэшем парсинга): ~20-30 сек

***

## 5. Технологический стек

### 5.1 Языки и платформы

| Компонент | Технология | Версия | Обоснование |
|-----------|------------|--------|-------------|
| **Язык** | Python | 3.10+ | Богатая экосистема AI/ML, простота разработки |
| **LLM API** | GigaChat | Latest | Требование проекта, российский LLM |
| **Фреймворк агентов** | GigaChain | 0.1+ | Официальная интеграция с GigaChat |

### 5.2 Библиотеки

| Библиотека | Назначение | Обоснование выбора |
|------------|------------|-------------------|
| **gigachat** | Клиент GigaChat API | Официальная библиотека |
| **gigachain** | Агентный фреймворк | Упрощает работу с GigaChat |
| **langchain** | Базовые абстракции | Стандарт индустрии для LLM apps |
| **chromadb** | Векторная БД | Embedded, легкая настройка |
| **pydantic** | Валидация данных | Type safety, structured output |
| **numpy** | Векторные операции | Обработка эмбеддингов |
| **python-dotenv** | Управление env переменными | Безопасность API ключей |
| **pyyaml** | Конфигурация | Читаемый формат настроек |
| **pytest** | Тестирование | De-facto стандарт для Python |

### 5.3 Альтернативы (рассмотренные, но не выбранные)

**FAISS vs ChromaDB**:
- ✅ FAISS: Быстрее для больших объемов (>100k векторов)
- ✅ ChromaDB: Проще в настройке, встроенная персистентность
- **Выбор**: ChromaDB (оптимален для объема проекта)

**LangChain vs Custom Implementation**:
- ✅ LangChain: Готовые абстракции, community support
- ✅ Custom: Полный контроль, меньше зависимостей
- **Выбор**: GigaChain + LangChain (ускорение разработки)

***

## 6. Структура данных

### 6.1 Внутренние модели (Pydantic)

#### Concept
```python
class Concept(BaseModel):
    title: str              # "Квантовая суперпозиция"
    description: str        # "Принцип, согласно которому..."
    importance: str         # "high" | "medium" | "low"
    context: str            # Релевантная цитата из заметки
```

#### ParsedNote
```python
class ParsedNote(BaseModel):
    concepts: List[Concept]  # 5-7 концепций
    summary: str             # Резюме всей заметки (2-3 предложения)
```

#### Question
```python
class Question(BaseModel):
    question_text: str                  # Текст вопроса
    question_type: str                  # "multiple_choice" | "true_false" | "short_answer"
    options: List[str] = []             # ["A", "B", "C", "D"] для multiple_choice
    correct_answer: str                 # "B" или текстовый ответ
    explanation: str                    # Краткое объяснение (1-2 предложения)
    difficulty: str                     # "easy" | "medium" | "hard"
```

#### Quiz
```python
class Quiz(BaseModel):
    questions: List[Question]  # Список вопросов
    total_questions: int       # Количество вопросов
```

### 6.2 Формат вывода (JSON)

**Пример полного вывода**:
```json
{
  "note_path": "data/sample_notes/quantum_mechanics.md",
  "parsed_concepts": {
    "concepts": [
      {
        "title": "Квантовая суперпозиция",
        "description": "Квантовая система может находиться в нескольких состояниях одновременно до момента измерения",
        "importance": "high",
        "context": "Суперпозиция - это фундаментальный принцип квантовой механики..."
      }
    ],
    "summary": "Заметка описывает основы квантовой механики, включая принципы суперпозиции и запутанности."
  },
  "quiz": {
    "questions": [
      {
        "question_text": "Что такое квантовая суперпозиция?",
        "question_type": "multiple_choice",
        "options": [
          "A) Состояние, когда частица находится в одном месте",
          "B) Состояние, когда частица может быть в нескольких состояниях одновременно",
          "C) Процесс измерения квантовой системы",
          "D) Взаимодействие двух частиц"
        ],
        "correct_answer": "B",
        "explanation": "Суперпозиция означает, что квантовая система существует во всех возможных состояниях одновременно до момента измерения.",
        "difficulty": "medium"
      }
    ],
    "total_questions": 7
  }
}
```

***

## 7. Архитектурные решения и компромиссы

### 7.1 Решение: Hash-based кэширование парсинга

**Проблема**: Parser Agent с RAG — дорогая операция (20-30 сек + множество API вызовов).

**Решение**: Кэширование результатов парсинга по MD5 хешу содержимого заметки.

**Преимущества**:
- ✅ Повторная генерация квиза занимает ~50% времени
- ✅ Экономия токенов GigaChat API
- ✅ Простая реализация (dict cache в памяти)

**Компромиссы**:
- ❌ Кэш живет только в рамках сессии (при перезапуске теряется)
- ❌ Память растет с количеством обработанных заметок

**Будущее улучшение**: Персистентный кэш на диске (pickle или Redis).

***

### 7.2 Решение: Модульная архитектура агентов

**Проблема**: Система должна легко расширяться (Explain Agent, Orchestrator Agent в будущем).

**Решение**: Базовый класс `BaseAgent` с абстрактным методом `process()`.

**Преимущества**:
- ✅ Единообразный интерфейс для всех агентов
- ✅ Легко добавлять новых агентов
- ✅ Независимое тестирование каждого агента
- ✅ Слабая связанность компонентов

**Компромиссы**:
- ❌ Небольшой overhead абстракции
- ❌ Требует дисциплины от разработчиков

***

### 7.3 Решение: RAG для длинных заметок

**Проблема**: GigaChat имеет лимит контекста (~8k токенов). Длинные лекции (>10k слов) не помещаются.

**Решение**: RAG система с chunking и семантическим поиском.

**Преимущества**:
- ✅ Обработка неограниченно длинных заметок
- ✅ Более релевантный контекст для анализа
- ✅ Оптимизация использования токенов

**Компромиссы**:
- ❌ Дополнительная сложность системы
- ❌ Зависимость от векторной БД (ChromaDB)
- ❌ Время индексации (~1-2 сек на заметку)

**Параметры chunking**:
- Размер чанка: 500 символов (баланс между контекстом и грануляцией)
- Overlap: 100 символов (сохранение контекста на границах)

***

### 7.4 Решение: Structured Output через Pydantic

**Проблема**: LLM может возвращать невалидный или непредсказуемый формат.

**Решение**: Принудительное использование Pydantic моделей для всех выводов агентов.

**Преимущества**:
- ✅ Гарантированная валидация данных
- ✅ Type safety на уровне Python
- ✅ Автогенерация JSON schema для промптов
- ✅ Легкая отладка и тестирование

**Компромиссы**:
- ❌ GigaChat не всегда возвращает идеальный JSON (требуется парсинг)
- ❌ Необходимость явного извлечения JSON из текста

**Реализация**:
```python
def _extract_json(text: str) -> str:
    start = text.find('{')
    end = text.rfind('}') + 1
    return text[start:end]
```

***

### 7.5 Решение: CLI интерфейс для предзащиты

**Проблема**: Нет времени на разработку UI и интеграцию с Obsidian до предзащиты.

**Решение**: Простой CLI интерфейс через `main.py`.

**Преимущества**:
- ✅ Быстрая разработка (1-2 часа)
- ✅ Простая демонстрация функциональности
- ✅ Легко автоматизировать тестирование
- ✅ Фокус на core логике, а не UI

**Компромиссы**:
- ❌ Менее впечатляющая демонстрация
- ❌ Требует технических навыков от пользователя

**Команда запуска**:
```bash
python -m src.main data/sample_notes/lecture.md
```

***

### 7.6 Решение: Отсутствие Orchestrator Agent на предзащите

**Проблема**: Orchestrator Agent — сложный компонент, требующий времени на разработку.

**Решение**: Линейный pipeline в `QuizPipeline.process_note()` вместо Orchestrator.

**Преимущества**:
- ✅ Простота реализации
- ✅ Легче отладка
- ✅ Соблюдение сроков предзащиты

**Компромиссы**:
- ❌ Нет гибкости в выборе агентов
- ❌ Сложнее добавлять условную логику
- ❌ Не демонстрирует полную агентную архитектуру

**Будущее**: Orchestrator будет добавлен для финальной версии.

***

## 8. Ограничения текущей версии (для предзащиты)

### 8.1 Функциональные ограничения

1. **Нет Explain Agent**
   - Отсутствует генерация объяснений при ошибках в квизе
   - Нет создания мнемонических образов для дворца памяти
   - **Планируется**: Добавить после предзащиты

2. **Нет Orchestrator Agent**
   - Линейный pipeline вместо гибкой оркестрации
   - Невозможно динамически выбирать агентов
   - **Планируется**: Реализовать для финальной защиты

3. **Нет памяти системы**
   - Quiz Agent не помнит предыдущие квизы
   - Возможны повторяющиеся вопросы
   - **Планируется**: Добавить контекст предыдущих квизов

4. **Только CLI интерфейс**
   - Нет интеграции с Obsidian
   - Нет графического интерфейса
   - **Планируется**: Разработать Obsidian плагин

### 8.2 Технические ограничения

1. **Кэш в памяти**
   - Кэш парсинга сбрасывается при перезапуске
   - Нет персистентности
   - **Решение**: Добавить файловый кэш или Redis

2. **Только текстовые заметки**
   - Не поддерживаются изображения
   - Не обрабатываются LaTeX формулы
   - Не парсятся таблицы
   - **Решение**: Добавить Markdown parsing с сохранением структуры

3. **Ограниченная обработка ошибок**
   - Базовая обработка исключений
   - Нет retry логики для API
   - Нет graceful degradation
   - **Решение**: Добавить robustness слой

4. **Нет метрик качества**
   - Отсутствует оценка качества вопросов
   - Нет A/B тестирования промптов
   - **Решение**: Добавить evaluation framework

### 8.3 Производительность

1. **Медленная первая генерация**
   - 40-60 секунд для заметки ~2000 слов
   - Много последовательных API вызовов
   - **Оптимизация**: Batch API calls где возможно

2. **Нет параллелизации**
   - Агенты работают строго последовательно
   - **Оптимизация**: Async/await для API вызовов

***

## 9. Планы развития (Roadmap)

### 9.1 После предзащиты (Week 1-2)

**Приоритет 1: Explain Agent**
- [ ] Реализовать Explain Agent класс
- [ ] Интеграция с Quiz Agent (trigger при ошибке)
- [ ] Промпт для генерации объяснений
- [ ] Промпт для создания мнемонических образов
- [ ] Тестирование качества объяснений

**Приоритет 2: Память системы**
- [ ] Хранилище истории квизов (SQLite или JSON)
- [ ] Механизм избегания повторов вопросов
- [ ] Контекст для Quiz Agent с предыдущими квизами
- [ ] Статистика прогресса пользователя

### 9.2 К финальной защите (Week 3-4)

**Приоритет 1: Orchestrator Agent**
- [ ] Реализовать Orchestrator класс
- [ ] Граф состояний агентной системы
- [ ] Условная логика выбора агентов
- [ ] Обработка ошибок и fallback стратегии
- [ ] Логирование workflow

**Приоритет 2: Интеграция с Obsidian**
- [ ] Разработка Obsidian плагина (TypeScript)
- [ ] API endpoint для Python backend
- [ ] UI для выбора заметки и настроек
- [ ] Отображение квиза в Obsidian
- [ ] Сохранение результатов в vault

**Приоритет 3: Улучшения качества**
- [ ] Поддержка LaTeX формул в заметках
- [ ] Парсинг изображений (OCR или caption)
- [ ] Обработка таблиц и списков
- [ ] Улучшение промптов (A/B тестирование)
- [ ] Evaluation framework для качества вопросов

### 9.3 Долгосрочные планы (Post-release)

**Feature 1: Адаптивные квизы**
- Spaced repetition (алгоритм Лейтнера или SM-2)
- Динамическая сложность вопросов
- Персонализация по слабым местам пользователя

**Feature 2: Мультимодальность**
- Поддержка видео лекций (транскрипция + анализ)
- Генерация диаграмм для визуализации концепций
- Аудио вопросы для слуховой памяти

**Feature 3: Социальные функции**
- Sharing квизов с друзьями
- Коллаборативное обучение
- Leaderboard и gamification

**Feature 4: Интеграции**
- Экспорт в Anki
- Интеграция с LMS (Moodle, Canvas)
- Синхронизация с Google Docs / Notion

***

## 10. Диаграммы

### 10.1 Sequence Diagram: Генерация квиза

```
User          QuizPipeline      ParserAgent      RAG System       GigaChat API      QuizAgent
 |                 |                 |                |                 |               |
 |--load note----->|                 |                |                 |               |
 |                 |--hash check-----|                |                 |               |
 |                 |                 |                |                 |               |
 |                 |--parse()------->|                |                 |               |
 |                 |                 |--chunk text--->|                 |               |
 |                 |                 |                |--embed--------->|               |
 |                 |                 |                |<--vectors-------|               |
 |                 |                 |                |--index in DB--->|               |
 |                 |                 |--extract topics----------------->|               |
 |                 |                 |<--topics list--------------------|               |
 |                 |                 |                |                 |               |
 |                 |                 |--retrieve(topic)---------------->|               |
 |                 |                 |<--chunks-------------------------|               |
 |                 |                 |--analyze topic------------------>|               |
 |                 |                 |<--Concept------------------------|               |
 |                 |                 |                |                 |               |
 |                 |<--ParsedNote----|                |                 |               |
 |                 |--cache result---|                |                 |               |
 |                 |                 |                |                 |               |
 |                 |--generate_quiz()-------------------------------------------------->|
 |                 |                 |                |                 |               |
 |                 |                 |                |      generate question--------->|
 |                 |                 |                |      <--Question----------------|
 |                 |<--Quiz-------------------------------------------------------------|
 |                 |                 |                |                 |               |
 |<--JSON output---|                 |                |                 |               |
```

### 10.2 Component Diagram: RAG System

```
┌────────────────────────────────────────────────────────┐
│                    RAG SYSTEM                          │
│                                                        │
│  ┌──────────────────────────────────────────────┐      │
│  │         EmbeddingGenerator                   │      │
│  │  • generate_embedding(text) → vector         │      │
│  │  • generate_embeddings_batch(texts) → List   │      │
│  └─────────────────┬────────────────────────────┘      │
│                    │ uses                              │
│                    ▼                                   │
│  ┌──────────────────────────────────────────────┐      │
│  │         VectorStore (ChromaDB)               │      │
│  │  • add_documents(chunks)                     │      │
│  │  • search(query, top_k) → List[str]          │      │
│  │  • clear()                                   │      │
│  │                                              │      │
│  │  Storage:                                    │      │
│  │  ├─ chunk_0: [emb_vector] → "текст чанка"    │      │
│  │  ├─ chunk_1: [emb_vector] → "текст чанка"    │      │
│  │  └─ ...                                      │      │
│  └─────────────────┬────────────────────────────┘      │
│                    │ used by                           │
│                    ▼                                   │
│  ┌──────────────────────────────────────────────┐      │
│  │         Retriever                            │      │
│  │  • retrieve(query, top_k) → List[str]        │      │
│  │  • retrieve_with_scores() → List[tuple]      │      │
│  └──────────────────────────────────────────────┘      │
│                                                        │
└────────────────────────────────────────────────────────┘
         ▲                                   ▲
         │ uses                              │ uses
         │                                   │
   ┌─────┴──────┐                      ┌─────┴──────┐
   │  Parser    │                      │  GigaChat  │
   │   Agent    │                      │  Embeddings│
   └────────────┘                      │    API     │
                                       └────────────┘
```

### 10.3 State Diagram: QuizPipeline

```
                    ┌──────────┐
                    │  START   │
                    └─────┬────┘
                          │
                          ▼
                  ┌───────────────┐
                  │  Load Config  │
                  └───────┬───────┘
                          │
                          ▼
              ┌──────────────────────┐
              │ Initialize Agents    │
              │ (Parser, Quiz)       │
              └──────────┬───────────┘
                         │
                         ▼
              ┌─────────────────────┐
              │  Load Note File     │
              └──────────┬──────────┘
                         │
                         ▼
              ┌─────────────────────┐
              │  Calculate Hash     │
              └──────────┬──────────┘
                         │
                    ┌────┴────┐
                    │ Hash in │
                    │ cache?  │
                    └─┬────┬──┘
                  YES │    │ NO
                      │    │
           ┌──────────┘    └───────────┐
           │                           │
           ▼                           ▼
    ┌────────────┐           ┌──────────────────┐
    │ Get Cached │           │  Run Parser      │
    │ ParsedNote │           │  Agent (20-30s)  │
    └─────┬──────┘           └────────┬─────────┘
          │                           │
          │                           ▼
          │                  ┌─────────────────┐
          │                  │  Cache Result   │
          │                  └────────┬────────┘
          │                           │
          └───────────┬───────────────┘
                      │
                      ▼
           ┌──────────────────────┐
           │  Run Quiz Agent      │
           │  (20-30s)            │
           └──────────┬───────────┘
                      │
                      ▼
           ┌──────────────────────┐
           │  Format Output       │
           │  (JSON)              │
           └──────────┬───────────┘
                      │
                      ▼
                 ┌─────────┐
                 │   END   │
                 └─────────┘
```

### 10.4 Data Flow Diagram

```
┌────────────────────────────────────────────────────────────────┐
│                         INPUT LAYER                            │
│                                                                │
│  User Note (Markdown)                                          │
│  • Title: "Квантовая механика"                                 │
│  • Content: 2000-5000 слов                                     │
│  • Sections: Введение, Основные принципы, Примеры              │
└────────────────────┬───────────────────────────────────────────┘
                     │
                     ▼
┌────────────────────────────────────────────────────────────────┐
│                    PROCESSING LAYER                            │
│                                                                │
│  ┌──────────────────────────────────────────────┐              │
│  │  Step 1: Text Chunking                       │              │
│  │  Input: Full text (2000 words)               │              │
│  │  Output: 10 chunks × 500 chars + 100 overlap │              │
│  └──────────────────┬───────────────────────────┘              │
│                     │                                          │
│                     ▼                                          │
│  ┌──────────────────────────────────────────────┐              │
│  │  Step 2: Embedding Generation                │              │
│  │  Input: 10 text chunks                       │              │
│  │  API Call: GigaChat Embeddings               │              │
│  │  Output: 10 vectors × 768 dimensions         │              │
│  └──────────────────┬───────────────────────────┘              │
│                     │                                          │
│                     ▼                                          │
│  ┌──────────────────────────────────────────────┐              │
│  │  Step 3: Vector Indexing (ChromaDB)          │              │
│  │  Input: 10 embeddings + texts                │              │
│  │  Storage: In-memory / Persistent DB          │              │
│  │  Index: Cosine similarity index              │              │
│  └──────────────────┬───────────────────────────┘              │
│                     │                                          │
│                     ▼                                          │
│  ┌──────────────────────────────────────────────┐              │
│  │  Step 4: Topic Extraction                    │              │
│  │  API Call: GigaChat LLM                      │              │
│  │  Prompt: "Извлеки 5-7 основных тем"          │              │
│  │  Output: ["Суперпозиция", "Запутанность"...] │              │
│  └──────────────────┬───────────────────────────┘              │
│                     │                                          │
│                     ▼                                          │
│  ┌──────────────────────────────────────────────┐              │
│  │  Step 5: RAG Retrieval (per topic)           │              │
│  │  For topic "Суперпозиция":                   │              │
│  │    • Query embedding generation              │              │
│  │    • Vector search (top_k=3)                 │              │
│  │    • Return relevant chunks                  │              │
│  └──────────────────┬───────────────────────────┘              │
│                     │                                          │
│                     ▼                                          │
│  ┌──────────────────────────────────────────────┐              │
│  │  Step 6: Concept Analysis                    │              │
│  │  API Call: GigaChat LLM (×5-7 topics)        │              │
│  │  Prompt: "Опиши концепцию с контекстом"      │              │
│  │  Output: Concept (title, desc, importance)   │              │
│  └──────────────────┬───────────────────────────┘              │
│                     │                                          │
│                     ▼                                          │
│  ┌──────────────────────────────────────────────┐              │
│  │  Step 7: Quiz Generation                     │              │
│  │  API Call: GigaChat LLM (×7 questions)       │              │
│  │  Prompt: Few-shot + Concept + JSON schema    │              │
│  │  Output: Question (text, type, options...)   │              │
│  └──────────────────┬───────────────────────────┘              │
│                                                                │
└────────────────────┬───────────────────────────────────────────┘
                     │
                     ▼
┌────────────────────────────────────────────────────────────────┐
│                      OUTPUT LAYER                              │
│                                                                │
│  JSON Response:                                                │
│  {                                                             │
│    "parsed_concepts": {                                        │
│      "concepts": [5-7 Concept objects],                        │
│      "summary": "Резюме заметки"                               │
│    },                                                          │
│    "quiz": {                                                   │
│      "questions": [7 Question objects],                        │
│      "total_questions": 7                                      │
│    }                                                           │
│  }                                                             │
└────────────────────────────────────────────────────────────────┘
```

***

## 11. Метрики успеха проекта

### 11.1 Технические метрики

| Метрика | Целевое значение | Измерение |
|---------|------------------|-----------|
| **Время генерации квиза** | < 60 сек | Для заметки 2000 слов |
| **Качество концепций** | 80% релевантность | Ручная оценка |
| **Разнообразие вопросов** | 3 типа вопросов | Автоматическая проверка |
| **Покрытие тестами** | > 70% | pytest coverage |
| **Uptime RAG системы** | 99% | Без ошибок индексации |

### 11.2 Пользовательские метрики (для финальной версии)

- Средний балл по квизу > 60% (студент понимает материал)
- Улучшение результатов после 3 повторений
- NPS (Net Promoter Score) > 50

***

## 12. Безопасность и приватность

### 12.1 Текущая версия

**API ключи**:
- Хранятся в `.env` файле (не коммитится в git)
- Загружаются через `python-dotenv`

**Данные пользователя**:
- Заметки не отправляются в сторонние сервисы (кроме GigaChat API)
- Векторная БД хранится локально

### 12.2 Планы

**Для Obsidian плагина**:
- Опция локального запуска (без облака)
- Шифрование кэша на диске
- Прозрачность использования API (логи)

***

## Заключение

Данная архитектура спроектирована с учетом:
- ✅ Модульности и расширяемости
- ✅ Оптимизации производительности (кэширование, RAG)
- ✅ Качества выходных данных (Pydantic, structured output)
- ✅ Реалистичных сроков разработки (предзащита)

Система готова к демонстрации базового функционала (Parser + Quiz Agent) и имеет четкий план развития до финальной версии с полным набором агентов и интеграцией в Obsidian.

***

**Версия документа**: 0.1.0-predeploy  
**Дата последнего обновления**: 28 октября 2025  
**Команда**: MindForge (5 человек)  
**Контакт**: [GitHub Repository Link]