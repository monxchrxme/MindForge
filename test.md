``` cpp
class Array{
	public:
		Array(int n) : Array(nullptr, n) {}
		Array(float*, int);
		Array(const Array &other) : Array(other.m, other.n) {} // констр копирования
		~Array(); // только 1

	private:
		float *m;
		int n;
};

Array::Array(float *m, int n) { // но если есть возвращаемое значение - оно перед всем
	this->n = n;
	this->m = new float[n];
	// Исключительные ситуации, пока просто вывод
	if(!m) {
		for (int i = 0; i < n; i++) {
			this->m[i]=0;
		}
	}
	else {
		for (int i = 0; i < n; i++) {
			this->m[i]=m[i];
		}
	}
}

Array::~Array(){
	if(m){
		delete []m;
		m=nullptr;
	}
}

```

Где есть динамика - деструктор обязателен
:: - оператор обращения к пространству имен

Конструктор копирования - единственный способ созданий копий объекта. есть у любого класса. Побайтовое копирование
``` cpp
Array a2 = a1; // запускается конструктор копирования
```

# Статические поля в классе
Обычное поле принадлежит объекту, статическое поле - принадлежит классу (ид объектов класса)
Статический метод - вызываемый через класс, а не через объект, из которого можно обращаться только к статическим полям класса и вызывать только статические методы

```cpp
class Book {
	public:
		static void setK(float k) {Bool::k = k}
		float getPrice() {
			return k*price;
		}


	private:
	std::string author;
	std::string title;
	//.....
	static float k; // статическое поле класса
	float price;
};

float Book::k; // глобальная переменная private



***
int main(){
	Book::k=1.2;//ошибка, тк k- приватный
}
```



# ООБ (оо библиотека)


# Константные объекты
те, которые обязательно инициализировать и нельзя менять(getter тоже не работает)
константная ссылка - нельзя изменить объект

**У них можно вызывать только константные методы и обращаться только к константным полям**

Любые методы не меняющие объект - const


- статическое поле - общее поле для всех элементов
- константное поле - нельзя менять
- статическое константное поле - для всех и нельзя менять

- статический константый метод ❌


# Бинарные операции класса

``` cpp
class Test{
	public:
		const Test operator+(const Test &rv) const { //rv - right value
			Test tmp(x+rv.x);
			return tmp;
			// или просто return *(new Test(x + rv.x));
		}
	private:
		int x;
};

***

int main(){
	Test t1(1), t2(2);
	Test t3=t1+t2;
	// t1+t2
	// t1.+(t2)
	
	//пока метод
	Test t3=t1.sum(t2);
}
```

- Нельзя переопределять точку
***
дз:
1. Разобраться с геттерами защищенных переменных 
2. Статические методы
3. реализовать в классе point: задавать свой id ❌
4. доработать класс точка до класса вектор (сумма векторов и скалярное произведение) через + и * , расстояние между точками(длину вектора) ❌
5. почему у константных объектов нельзя вызвать геттер
